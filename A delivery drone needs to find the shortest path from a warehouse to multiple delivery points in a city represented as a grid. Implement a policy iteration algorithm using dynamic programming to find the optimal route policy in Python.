import numpy as np
import random
N = 4
grid = [
    [-1, -1, -1, -1],
    [-1, -1, -1, -1],
    [-1, -1, -1, -1],
    [-1, -1, -1, 10]
]

actions = [(-1,0), (1,0), (0,-1), (0,1)]  
gamma = 0.9
V = np.zeros((N, N))
policy = [[random.choice(actions) for _ in range(N)] for _ in range(N)]

def next_state(r, c, a):
    nr, nc = r + a[0], c + a[1]
    return (nr, nc) if 0 <= nr < N and 0 <= nc < N else (r, c)
while True:
    for _ in range(20):
        for r in range(N):
            for c in range(N):
                nr, nc = next_state(r, c, policy[r][c])
                V[r][c] = grid[nr][nc] + gamma * V[nr][nc]

    stable = True
    for r in range(N):
        for c in range(N):
            old = policy[r][c]
            policy[r][c] = max(
                actions,
                key=lambda a: grid[next_state(r, c, a)[0]][next_state(r, c, a)[1]]
                              + gamma * V[next_state(r, c, a)]
            )
            if old != policy[r][c]:
                stable = False

    if stable:
        break
print("Optimal Value Function:\n", np.round(V, 2))
print("\nOptimal Policy (U,D,L,R):")
for r in range(N):
    print([('U','D','L','R')[actions.index(policy[r][c])] for c in range(N)])
